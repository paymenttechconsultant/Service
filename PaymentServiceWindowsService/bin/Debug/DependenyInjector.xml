<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DependenyInjector</name>
    </assembly>
    <members>
        <member name="T:DependenyInjector.DependencyInjector">
            <summary>
            DependencyInjector is designed to control what should be returned when object creation is requested.
            In most situation it creates and returns new object of class given as second template argument of Get
            We can override this behavior in two ways: 
             - by setting type returned for requested interface - new object of this type will be created every time
             - by setting exact object 
            For working simple example see unit test for this class
            </summary>
        </member>
        <member name="T:DependenyInjector.DependencyInjector.ResolvableType">
            <summary>
            Helper class to check if given pair of types can match and eventually put them in dictionary
            </summary>
        </member>
        <member name="M:DependenyInjector.DependencyInjector.ResolvableType.As``1">
            <summary>
            By template parameter developer points which type(interface) should be covered
            </summary>
            <typeparam name="T">Type we want to override</typeparam>
        </member>
        <member name="M:DependenyInjector.DependencyInjector.ResolvableType.#ctor(System.Type)">
            <summary>
            Simple constructor - takes Type of objects to be returned
            </summary>
            <param name="i"></param>
        </member>
        <member name="T:DependenyInjector.DependencyInjector.ResolvableObject">
            <summary>
            Helper class to check if given pair: object-type can match and eventually put them in dictionary
            </summary>
        </member>
        <member name="M:DependenyInjector.DependencyInjector.ResolvableObject.As``1">
            <summary>
            By template parameter developer points which type(interface) should be covered
            </summary>
            <typeparam name="T">Type we want to override</typeparam>
        </member>
        <member name="M:DependenyInjector.DependencyInjector.ResolvableObject.#ctor(System.Object)">
            <summary>
            Simple constructor - takes Object to be returned
            </summary>
            <param name="o">Object to be returned</param>
        </member>
        <member name="M:DependenyInjector.DependencyInjector.Register``1">
            <summary>
            Method used to create new Type-Type mapping. Note that As() must be called on returned object
            if not - nothing will happen
            </summary>
            <typeparam name="T">Type to be registered</typeparam>
            <returns>ResolvableType</returns>
        </member>
        <member name="M:DependenyInjector.DependencyInjector.Get``2">
            <summary>
            Method used to get object. First it will check for T in 
            object/type mapping dictionaries and return what was found. If no mapping is set it will return new object of type U. 
            Note that T-U must be related. Example T t = new U() must be correct cast.
            </summary>
            <typeparam name="T">Type we want (general, interface)</typeparam>
            <typeparam name="U">More specified - exact type we need</typeparam>
            <returns>Object of type T</returns>
        </member>
        <member name="M:DependenyInjector.DependencyInjector.Register(System.Object)">
            <summary>
            Method used to create new Type-Object mapping. Note that As() must be called on returned object
            if not - nothing will happen
            </summary>
            <param name="o">Object to be returned when Get() called for proper type</param>
            <returns></returns>
        </member>
    </members>
</doc>
